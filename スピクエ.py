# -*- coding: utf-8 -*-
"""ã‚¹ãƒ”ã‚¯ã‚¨.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KCQ2INj2xTpe2YxxqfphD-bzsSKjtYeg

## Read Me

ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç›®æŒ‡ã›ç²¾éœŠç‹ï¼ã‚¹ãƒ”ãƒªãƒƒãƒˆã‚­ãƒ³ã‚°ã‚¯ã‚¨ã‚¹ãƒˆã®ã‚¹ã‚­ãƒ«CTæ¯”è¼ƒç”¨ã®ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ï¼ãƒ­ãƒ¼ã‚«ãƒ«ã§ã®å®Ÿè¡Œã§ã¯ãªã„ç‚ºï¼Œã‚ãªãŸã®ç’°å¢ƒã«ã¯ä¸€åˆ‡å¤‰æ›´ã‚’ä¸ãˆãªã„ã®ã§å®‰å¿ƒã—ã¦ãã ã•ã„ï¼<br>

äº‹å‰æº–å‚™ã¯ã“ã®ã‚µã‚¤ãƒˆã‚’é–‹ã„ãŸã¨ãã«**æœ€åˆã ã‘å®Ÿè¡Œ**ã—ï¼Œä»¥é™ã¯å®Ÿè¡Œã—ãªã„ã§ãã ã•ã„ï¼(ã—ã¦ã‚‚å¤§ä¸ˆå¤«ã§ã™ãŒæ„å‘³ãªã„ã§ã™)<br>

## äº‹å‰æº–å‚™

äº‹å‰æº–å‚™ã«ã¯ã‚¹ã‚­ãƒ«æ™‚é–“é‡è¤‡æ¯”è¼ƒã‚’ã™ã‚‹ãŸã‚ã®æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆã®è¡¨ç¤ºã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨å®Ÿè¡Œç”¨é–¢æ•°åŠã³ã‚¹ã‚­ãƒ«ãƒªã‚¹ãƒˆãŒå«ã¾ã‚Œã¦ã„ã¾ã™
"""

# IPAexã‚´ã‚·ãƒƒã‚¯ãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦æœ‰åŠ¹åŒ–ï¼ˆColabå°‚ç”¨ï¼‰
!wget -q https://moji.or.jp/wp-content/ipafont/IPAexfont/ipaexg00301.zip
!unzip -o ipaexg00301.zip
!mkdir -p ~/.fonts
!mv ipaexg00301/*.ttf ~/.fonts/
!fc-cache -fv

# ãƒ•ã‚©ãƒ³ãƒˆã‚’æ˜ç¤ºçš„ã«Matplotlibã«ç™»éŒ²
from matplotlib.font_manager import FontProperties
font_path = "/root/.fonts/ipaexg.ttf"
font_prop = FontProperties(fname=font_path)

skills = [
    {"Name": "ãƒ¯ãƒ³ãƒ¯ãƒ³ãƒœãƒ³ãƒãƒ¼", "CT": 3.45, "Effect Time": 2.0},
    {"Name": "ãƒ–ãƒªã‚¶ãƒ¼ãƒ‰", "CT": 4.5, "Effect Time": None},  # å³æ™‚å‹
    {"Name": "ãƒ—ãƒ­ãƒ†ã‚¯ã‚·ãƒ§ãƒ³", "CT": 3.9, "Effect Time": 1.5},
    {"Name": "ãƒ©ã‚°ãƒŠãƒ­ã‚¯", "CT": 3.0, "Effect Time": None},
    {"Name": "ãƒãƒ³ãƒ‰ãƒ¬ã‚¤ã‚¯çˆ†å¼¾", "CT": 4.85, "Effect Time": 2.5},
    {"Name": "ãƒ”ã‚¢ã‚·ãƒ³ã‚°ã‚½ãƒ¼ãƒ‰", "CT": 3.25, "Effect Time": None},
    {"Name": "è‡ªç„¶ã®åŠ›", "CT": 3.75, "Effect Time": 2},
    {"Name": "ãƒã‚¤ã‚ºãƒ³ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰", "CT": 4.95, "Effect Time": 2.5},
    {"Name": "åœ°ç„ç«", "CT": 4.5, "Effect Time": None},
    {"Name": "ç²¾éœŠåœ°éœ‡", "CT": 3.5, "Effect Time": None},
    {"Name": "ç‚ã®é­", "CT": 3.95, "Effect Time": 2.0},
    {"Name": "äº¡è€…ã®å •è½", "CT": 3.0, "Effect Time": None},
    {"Name": "ã‚­ãƒ³ã‚°ã‚¹ãƒ©ã‚¤ãƒ å¬å–š", "CT": 3.35, "Effect Time": None},
    {"Name": "ãƒ‰ãƒ©ã‚´ãƒ³ã‚¹ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ©ãƒ³ã‚¹", "CT": 3.75, "Effect Time": 2},
    {"Name": "çŒ«ã®è¶³è·¡", "CT": 5, "Effect Time": None},
    {"Name": "æœˆå…‰æ–¬ã‚Š", "CT": 4.0, "Effect Time": None},
    {"Name": "ã‚´ãƒƒãƒ‰ãƒ•ã‚£ã‚¹ãƒˆ", "CT": 4.5, "Effect Time": None},
    {"Name": "ç«å±±çˆ†ç™º", "CT": 4.45, "Effect Time": 2.5},
    {"Name": "ãƒ‡ã‚¹ã‚µã‚¤ã‚º", "CT": 4.7, "Effect Time": 2.5},
    {"Name": "ãƒ™ãƒ’ãƒ¢ã‚¹å¬å–š", "CT": 3.9, "Effect Time": None},
    {"Name": "ãƒ‰ãƒ©ã‚´ãƒ³ãƒ–ãƒ¬ã‚¹", "CT": 3.85, "Effect Time": None},
    {"Name": "ãƒ•ã‚§ãƒ‹ãƒƒã‚¯ã‚¹å¬å–š", "CT": 4.3, "Effect Time": 2.0},
    {"Name": "ã‚¢ãƒ«ãƒã‚²ãƒ‰ãƒ³", "CT": 4.75, "Effect Time": None}
]

import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.colors import hsv_to_rgb
import numpy as np

def time_overlap(start1, end1, start2, end2):
    return max(0, min(end1, end2) - max(start1, start2))

def generate_distinct_colors(n):
    hues = np.linspace(0, 1, n + 1)[:-1]
    return [hsv_to_rgb((h, 0.6, 0.9)) for h in hues]

def plot_skills_jp(skills, total_time=30, mode="ranking event"):
    fig, ax = plt.subplots(figsize=(12, 6))
    y_labels = [s["Name"] for s in skills]
    colors = generate_distinct_colors(len(skills))
    effect_ranges = [[] for _ in skills]
    bar_height = 0.3

    # === å³æ™‚ã‚¹ã‚­ãƒ«æ™‚é–“åé›†ï¼ˆå°æ•°ä¸¸ã‚ï¼‰ ===
    instant_times = {}

    for i, skill in enumerate(skills):
        ct = float(skill['CT'])
        effect_time = float(skill.get('Effect Time') or 0)
        color = colors[i]
        current_time = 0

        while current_time <= total_time:
            start = current_time + ct if mode == "ranking event" else current_time
            end = start + effect_time
            if start > total_time:
                break

            if effect_time > 0:
                # é€šå¸¸ã‚¹ã‚­ãƒ«æç”»
                ax.add_patch(patches.Rectangle((start, i - bar_height / 2), end - start, bar_height,
                                               color=color, alpha=0.6))
                effect_ranges[i].append((start, end))
            else:
                # å³æ™‚ã‚¹ã‚­ãƒ«è¨˜éŒ²ï¼ˆkeyã‚’ä¸¸ã‚ã¦ä¸€è‡´å‡¦ç†ï¼‰
                key = round(start, 2)
                instant_times.setdefault(key, []).append(i)

            current_time += ct

    # === é‡è¤‡åŠ¹æœãƒãƒ¼ï¼ˆèµ¤ï¼‰ ===
    for i in range(len(skills)):
        for j in range(i + 1, len(skills)):
            for si, ei in effect_ranges[i]:
                for sj, ej in effect_ranges[j]:
                    if time_overlap(si, ei, sj, ej):
                        ov_start = max(si, sj)
                        ov_end = min(ei, ej)
                        for y in [i, j]:
                            ax.add_patch(patches.Rectangle((ov_start, y - bar_height / 2), ov_end - ov_start, bar_height,
                                                           color='red', alpha=0.8))

    # === å³æ™‚ã‚¹ã‚­ãƒ«æç”»ï¼ˆplotã§æ˜ç¤ºYè»¸ã€é‡è¤‡ã¯ç‚¹ç·šï¼‰ ===
    for t, indices in instant_times.items():
        for i in indices:
            # ä»–ã‚¹ã‚­ãƒ«ã®åŠ¹æœæ™‚é–“ã¨é‡è¤‡ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            overlaps_effect = False
            for j, ranges in enumerate(effect_ranges):
                if j == i:
                    continue
                for start, end in ranges:
                    if start <= t <= end:
                        overlaps_effect = True
                        break
                if overlaps_effect:
                    break

            color = 'red' if len(indices) > 1 else 'blue'
            linestyle = ':' if overlaps_effect else '-'
            ax.plot([t, t], [i - bar_height / 2, i + bar_height / 2],
                    color=color, linestyle=linestyle, linewidth=1.8, alpha=0.9)

    # === è»¸ã¨ã‚¿ã‚¤ãƒˆãƒ« ===
    ax.set_ylim(-1, len(skills))
    ax.set_xlim(0, total_time)
    ax.set_yticks(range(len(skills)))
    ax.set_yticklabels(y_labels, fontproperties=font_prop)
    ax.set_xlabel("æ™‚é–“ï¼ˆç§’ï¼‰", fontproperties=font_prop)
    ax.set_title(f"ã‚¹ã‚­ãƒ«CTã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ï¼ˆ{mode}ï¼‰", fontproperties=font_prop)
    ax.grid(axis='x', linestyle='--', alpha=0.6)
    plt.tight_layout()
    plt.show()

    print("ğŸ“ ã‚¹ã‚­ãƒ«æƒ…å ±ï¼š")
    for s in skills:
        et = s.get('Effect Time')
        print(f"ãƒ»{s['Name']}ï¼šCT={s['CT']}ç§’, åŠ¹æœæ™‚é–“={'å³æ™‚' if not et else f'{et}ç§’'}")

"""## ã‚¹ã‚­ãƒ«/ãƒ¢ãƒ¼ãƒ‰é¸æŠ

ã“ã®ã‚»ãƒ«ã¯ã‚¹ã‚­ãƒ«ã®é¸æŠåŠã³ãƒ¢ãƒ¼ãƒ‰ã®é¸æŠç”»é¢ã«ãªã‚Šã¾ã™ï¼<br>
ãƒ¢ãƒ¼ãƒ‰é¸æŠã§ã¯ï¼Œranking eventã¨normal stageã®2ã¤ãŒã‚ã‚Šã¾ã™ï¼

*   ranking eventã¯0ç§’æ™‚ç‚¹ã§CTãŒé©ç”¨ã•ã‚Œã¦ã„ã‚‹çŠ¶æ…‹ã§ã™
*   normal stageã¯0ç§’æ™‚ç‚¹ã§ã™ã¹ã¦ã®ã‚¹ã‚­ãƒ«ãŒä½¿ç”¨ã—ãŸçŠ¶æ…‹ã§ã™

æ™‚é–“ã®é¸æŠã‚‚30ç§’ã¨40ç§’ã®2ç¨®é¡ã‚’é¸æŠå¯èƒ½ã§ã™ï¼

ã‚¹ã‚­ãƒ«é¸æŠã¯è¤‡æ•°é¸æŠå¯èƒ½ã§ã™ï¼ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒé’ãè¡¨ç¤ºã•ã‚Œã¦ã„ã‚Œã°é¸æŠå®Œäº†ã§ã™ï¼<br>

åŠ¹æœæ™‚é–“ã®ã‚ã‚‹ã‚¹ã‚­ãƒ«ã®é‡è¤‡æœŸé–“ã¯ã™ã¹ã¦èµ¤ãè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ãŸã‚ï¼Œæ¯”è¼ƒã‚’è¦‹ã‚„ã™ãã—ãŸã„éš›ã¯3å€‹ç¨‹åº¦ãŒãŠã™ã™ã‚ã§ã™ï¼
"""

import ipywidgets as widgets
from IPython.display import display

checkboxes = [widgets.Checkbox(value=False, description=s["Name"]) for s in skills]

mode_selector = widgets.ToggleButtons(
    options=['ranking event', 'normal stage'],
    description='ãƒ¢ãƒ¼ãƒ‰:'
)
time_selector = widgets.Dropdown(
    options=[30, 40],
    value=30,
    description='æ™‚é–“:'
)

display(mode_selector, time_selector, widgets.Label("ã‚¹ã‚­ãƒ«é¸æŠ:"), widgets.VBox(checkboxes))

"""## æç”»å®Ÿè¡Œ

ã“ã®ã‚»ãƒ«ã¯ã‚¹ã‚­ãƒ«é¸æŠå¾Œã«å®Ÿè¡Œã—ã¦ãã ã•ã„ï¼<br>
æ¯”è¼ƒçµæœã®ç”»åƒãŒå‡ºåŠ›ã•ã‚Œã¾ã™.ã‚¹ã‚­ãƒ«åŠ¹æœæ™‚é–“ã®ã‚ã‚‹ã‚¹ã‚­ãƒ«åŒå£«ã®é‡è¤‡æœŸé–“ã¯èµ¤ãè¡¨ç¤ºã•ã‚Œã¾ã™ï¼<br>
ã¾ãŸã€å³æ™‚å‹ãŒåŠ¹æœæ™‚é–“ã®ã‚ã‚‹ã‚¹ã‚­ãƒ«ã®åŠ¹æœæ™‚é–“ã¨é‡è¤‡ã—ã¦ã„ãŸå ´åˆã¯ç‚¹ç·šã§è¡¨ç¤ºã•ã‚Œã¾ã™.ãã‚Œä»¥å¤–ã¯ç›´ç·šã§è¡¨ç¤ºã•ã‚Œã¾ã™.<br>
yè»¸ã«ã¯ã‚¹ã‚­ãƒ«åç§°ï¼Œxè»¸ã«ã¯æ™‚é–“ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ï¼
"""

selected_skills = [
    {**skills[i], "Name": checkboxes[i].description}
    for i in range(len(checkboxes)) if checkboxes[i].value
]

plot_skills_jp(
    skills=selected_skills,
    total_time=time_selector.value,
    mode=mode_selector.value
)